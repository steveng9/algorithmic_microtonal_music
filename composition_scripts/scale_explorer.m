% scale_explorer.m
%
% Generates a multi-voice score of ascending and descending 5-lets and
% 6-lets for exploring custom scales and tunings.
%
% Each of V voices independently chooses ascending or descending runs of
% 5 or 6 stepwise scale degrees and modulates randomly at each phrase
% boundary. Measure length is not fixed — it is determined dynamically by
% when the active voices' phrase boundaries next coincide.  Since all
% phrases are 5 or 6 eighths, alignment is guaranteed within LCM(5,6)=30
% eighths.  This means short, tightly-locked measures when voices happen
% to pick the same x-let size, and longer interlocked measures when they
% diverge.
%
% KEY / TUNING:
%   KEY    = 'Ab major'                         named mode
%   KEY    = 'Ab [1,3,5,6,8,10,12]'            custom 1-indexed TET semitone positions
%   KEY    = 'Ab [1/1,9/8,5/4,4/3,3/2,5/3,15/8]'  explicit JI ratios
%   TUNING = 'tet'   (default; writes no tuning: line)
%   TUNING = 'ji'    auto-maps major/minor to 5-limit JI
%   TUNING = 'pythagorean_major' / 'major_7limit' / etc.
%
% Transition rules at each phrase boundary (per voice):
%   P_TOGGLE: flip ascend/descend; new start within ±2 degrees of the
%     previous end note (gap ≤ major third).
%   1-P_TOGGLE (same direction), two sub-cases:
%     P_CONNECT: step 1-2 degrees further in same direction — produces
%       10 (5+5), 11 (5+6 or 6+5), or 12 (6+6) note runs.
%     1-P_CONNECT: jump back near the previous phrase start (±0,1,2 deg).
%
% ---- Parameters (edit these) ----------------------------------------

KEY        = 'Ab [1,3,5,6,8,10,11]';  % tonic + scale
TUNING     = 'ji';                    % 'tet', 'ji', or a specific JI scale name
V          = 4;                        % number of voices
D          = 4;                      % avg voices playing simultaneously
BPM        = 200;
N_MEASURES = 32;                       % number of dynamic-length measures

SOUND_FUNC    = 'kind_music_box';
OCTAVE_SHIFTS = [];  % one per voice, high to low; auto-spreads if empty

RANGE_MIN  = 1;    % lowest allowed scale degree
RANGE_MAX  = 10;   % highest allowed scale degree

P_TOGGLE   = 0.2;  % probability of flipping direction at each phrase boundary
P_CONNECT  = 0.5;  % given same direction: prob of connecting vs jumping back

OUTPUT_SCORE = 'scores/scale_explorer.txt';

% ---------------------------------------------------------------------

rng('shuffle');

if isempty(OCTAVE_SHIFTS)
    top = floor((V - 1) / 2);
    OCTAVE_SHIFTS = top : -1 : (top - (V - 1));
end
if length(OCTAVE_SHIFTS) ~= V
    error('OCTAVE_SHIFTS must have V=%d entries.', V);
end
if RANGE_MAX - RANGE_MIN < 5
    error('RANGE_MAX - RANGE_MIN must be at least 5 to fit a 5-let.');
end

% Density: n_low voices with probability p_low, n_high voices otherwise
n_low  = floor(D);
n_high = ceil(D);
p_low  = n_high - D;   % = ceil(D) - D

% Initial voice states: degrees spread across the range, random directions
degrees    = round(linspace(RANGE_MIN + 2, RANGE_MAX - 2, max(V, 2)));
degrees    = degrees(1:V);
directions = (rand(1, V) < 0.5) * 2 - 1;  % +1 ascending, -1 descending

MAX_MEAS = 30;  % safety cap = LCM(5,6); alignment always happens by here

% ---- Build score -------------------------------------------------------
out = {};

out{end+1} = 'Scale Explorer';
out{end+1} = sprintf('(%d)', year(datetime('today')));
out{end+1} = 'generated by scale_explorer.m';
out{end+1} = '';

for v = 1:V
    out{end+1} = sprintf('voice: v%d, @%s, %d', v, SOUND_FUNC, OCTAVE_SHIFTS(v));
end
if ~strcmpi(TUNING, 'tet')
    out{end+1} = sprintf('tuning: %s', TUNING);
end

out{end+1} = '';
out{end+1} = sprintf('qtr_note = %d', BPM);
out{end+1} = KEY;
out{end+1} = '';

for m = 1:N_MEASURES

    % --- Pick active voices for this measure ----------------------------
    if rand() < p_low
        n_active = n_low;
    else
        n_active = n_high;
    end
    n_active = min(n_active, V);

    if n_active == 0
        % All voices rest; use a 5-eighth placeholder
        for v = 1:V, out{end+1} = 'r.5'; end
        out{end+1} = '';
        continue;
    end

    active_set = randperm(V, n_active);
    is_active  = ismember(1:V, active_set);

    % --- Greedy alignment -----------------------------------------------
    % Advance whichever active voice(s) are furthest behind.
    % Voices independently choose 5-let or 6-let phrases until all share
    % the same cumulative total.  Capped at MAX_MEAS eighths.
    cumulatives  = zeros(1, V);
    voice_notes  = cell(1, V);
    for v = 1:V, voice_notes{v} = {}; end

    while true
        active_cums = cumulatives(is_active);

        % Aligned when all active voices share the same positive total
        if active_cums(1) > 0 && all(active_cums == active_cums(1))
            break;
        end

        min_cum = min(active_cums);

        % Safety: if no 5-let fits from the current minimum, stop
        if min_cum + 5 > MAX_MEAS
            break;
        end

        % Advance every active voice sitting at the minimum
        for v = 1:V
            if ~is_active(v) || cumulatives(v) ~= min_cum
                continue;
            end

            % Choose x-let; if the preferred size would exceed the cap,
            % try the other; skip if neither fits (voice will be padded)
            xlet = 5 + (rand() < 0.5);
            if min_cum + xlet > MAX_MEAS
                xlet = 11 - xlet;   % flip 5↔6
            end
            if min_cum + xlet > MAX_MEAS
                continue;           % neither fits; skip (rare safety case)
            end

            deg = degrees(v);
            dir = directions(v);

            % Range enforcement: flip direction if phrase would overshoot
            if dir == 1 && deg + xlet - 1 > RANGE_MAX
                dir = -1;
            elseif dir == -1 && deg - xlet + 1 < RANGE_MIN
                dir = 1;
            end

            % Clamp starting degree so entire phrase stays in range
            if dir == 1
                deg = max(RANGE_MIN, min(RANGE_MAX - xlet + 1, deg));
            else
                deg = max(RANGE_MIN + xlet - 1, min(RANGE_MAX, deg));
            end

            % Emit phrase
            for n = 0:xlet-1
                voice_notes{v}{end+1} = sprintf('%d.1', deg + dir * n);
            end
            cumulatives(v) = cumulatives(v) + xlet;

            % --- Compute transition to next phrase ----------------------
            end_deg = deg + dir * (xlet - 1);

            if rand() < P_TOGGLE
                % Toggle direction; gap ≤ major third (2 scale degrees)
                new_dir = -dir;
                new_deg = end_deg + randi([-2, 2]);
            else
                % Same direction
                new_dir = dir;
                if rand() < P_CONNECT
                    % Connect: step 1 or 2 degrees further in same dir
                    new_deg = end_deg + dir * randi([1, 2]);
                else
                    % Jump back near previous phrase start (±0,1,2 deg)
                    new_deg = deg + randi([-2, 2]);
                end
            end

            degrees(v)    = max(RANGE_MIN, min(RANGE_MAX, new_deg));
            directions(v) = new_dir;
        end
    end

    % measure_len = longest active voice; pad any shorter voice with a rest
    measure_len = max(cumulatives(is_active));
    for v = find(is_active)
        if cumulatives(v) < measure_len
            voice_notes{v}{end+1} = sprintf('r.%d', measure_len - cumulatives(v));
        end
    end

    % --- Write voice lines ----------------------------------------------
    for v = 1:V
        if is_active(v)
            out{end+1} = strjoin(voice_notes{v}, ', ');
        else
            out{end+1} = sprintf('r.%d', measure_len);
        end
    end
    out{end+1} = '';
end

% ---- Write file --------------------------------------------------------
addpath('sounds/');

fid = fopen(OUTPUT_SCORE, 'w');
if fid == -1
    error('Could not open output file: %s', OUTPUT_SCORE);
end
for i = 1:length(out)
    fprintf(fid, '%s\n', out{i});
end
fclose(fid);
fprintf('Score written to %s\n', OUTPUT_SCORE);

% ---- Format, synthesise, play ------------------------------------------
microtonal.notation.format_score(OUTPUT_SCORE);
buf = microtonal.notation.notation_to_audio(OUTPUT_SCORE);
microtonal.audio.play('scale_explorer', buf);
