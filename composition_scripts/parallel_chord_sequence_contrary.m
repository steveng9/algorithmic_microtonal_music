% parallel_chord_sequence_contrary.m
%
% Extension of parallel_chord_sequence.m with two additions:
%
%   1. CONTRARY MOTION: the bass (v5) and one inner voice (v4) play the
%      sequence inverted â€” they mirror the main sequence around their
%      starting degree (contrary / anti-parallel motion).
%
%   2. RHYTHM PERMUTATION: the 8 note durations are shuffled randomly
%      each repetition, so the rhythm changes while the total duration
%      stays fixed (guaranteeing all voices stay measure-aligned).
%
% ---- Parameters (edit these) ----------------------------------------

SEQUENCE      = [1, 2, 3, 4, 3, 2, 3, 1];  % melodic pattern (scale degrees)
% SEQUENCE      = [6, 5, 4, 3, 4, 3, 2, 1];  % melodic pattern (scale degrees)
COUNTER_SEQ   = [6, 5, 6, 4, 6, 3, 6, 2];  % counter-voice sequence; leave [] to auto-mirror SEQUENCE
% COUNTER_SEQ   = [1, 2, 3, 4, 3, 2, 3, 1];  % counter-voice sequence; leave [] to auto-mirror SEQUENCE
CHORD_STACK   = [5, 1, 2, 1, 3];           % starting degree for each of 5 voices
RHYTHM        = [5, 4, 4, 4, 4, 5, 6, 7];  % duration in eighths per note position
COUNTER_RHYTHM = [4, 5, 4, 3, 5, 6, 6, 6];  % counter-voice rhythm; leave [] to share RHYTHM
COUNTER_VOICES = [4, 5];                    % voice indices that play contrary motion
delta_options    = [-3, -1, 0, 2];
N_REPETITIONS = 12;
BPM           = 270;
KEY           = 'E [1,3,5,7,8,10,12]';
% KEY           = 'Ab dorian';
SCALE         = [];  % custom TET scale, 1-indexed (e.g. [1,3,5,6,8,10,12]); [] = use mode name from KEY
SOUND_FUNC    = 'kind_music_box';
OCTAVE_SHIFTS = [0, 0, 0, -1, -2];         % one per voice, high to low

OUTPUT_SCORE  = 'scores/parallel_chord_sequence_contrary.txt';

% ---------------------------------------------------------------------

if length(SEQUENCE) ~= length(RHYTHM)
    error('SEQUENCE and RHYTHM must have the same length.');
end

n_voices = length(CHORD_STACK);
seq_len  = length(SEQUENCE);

if length(OCTAVE_SHIFTS) ~= n_voices
    error('OCTAVE_SHIFTS must have %d entries (one per voice).', n_voices);
end

rng('shuffle');

% Parallel sequence offsets: voice v plays SEQUENCE(i) + offset(v)
base_offsets = CHORD_STACK - SEQUENCE(1);

% Counter rhythm used by COUNTER_VOICES.
% Must have the same length and total duration as RHYTHM so measures align.
if isempty(COUNTER_RHYTHM)
    counter_rhythm = RHYTHM;
else
    if length(COUNTER_RHYTHM) ~= seq_len
        error('COUNTER_RHYTHM must have the same length as RHYTHM (%d).', seq_len);
    end
    if sum(COUNTER_RHYTHM) ~= sum(RHYTHM)
        error('COUNTER_RHYTHM must sum to %d (same total as RHYTHM).', sum(RHYTHM));
    end
    counter_rhythm = COUNTER_RHYTHM;
end

% Counter sequence used by COUNTER_VOICES.
% If COUNTER_SEQ is set, use it directly (must be same length as SEQUENCE).
% Otherwise, auto-mirror: invert each step around SEQUENCE(1).
if isempty(COUNTER_SEQ)
    counter_seq = 2 * SEQUENCE(1) - SEQUENCE;
else
    if length(COUNTER_SEQ) ~= seq_len
        error('COUNTER_SEQ must have the same length as SEQUENCE (%d).', seq_len);
    end
    counter_seq = COUNTER_SEQ;
end

% ---- Build score lines -----------------------------------------------
out = {};

out{end+1} = 'Parallel Chord Sequence with Contrary Motion';
out{end+1} = sprintf('(%d)', year(datetime('today')));
out{end+1} = 'generated by parallel_chord_sequence_contrary.m';
out{end+1} = '';

for v = 1:n_voices
    out{end+1} = sprintf('voice: v%d, @%s, %d', v, SOUND_FUNC, OCTAVE_SHIFTS(v));
end

% out{end+1} = 'tuning: ji';
out{end+1} = '';
out{end+1} = sprintf('qtr_note = %d', BPM);
if isempty(SCALE)
    out{end+1} = KEY;
else
    key_parts = strsplit(KEY);
    scale_str = strjoin(arrayfun(@num2str, SCALE, 'UniformOutput', false), ',');
    out{end+1} = sprintf('%s [%s]', key_parts{1}, scale_str);
end
out{end+1} = '';

cumulative_delta = 0;

for rep = 1:N_REPETITIONS
    if rep > 1
        step             = delta_options(randi(length(delta_options)));
        cumulative_delta = cumulative_delta + step;
        cumulative_delta = max(-8, min(8, cumulative_delta));
    end

    % Shuffle the rhythm durations for this repetition.
    % Total duration is preserved, so all voices stay measure-aligned.
    % rhythm = RHYTHM(randperm(seq_len));
    % counter_rhythm = COUNTER_RHYTHM(randperm(seq_len));
    rhythm = RHYTHM;

    for v = 1:n_voices
        voice_offset = base_offsets(v) + cumulative_delta;

        if ismember(v, COUNTER_VOICES)
            seq_to_use    = counter_seq;
            rhythm_to_use = counter_rhythm;
        else
            seq_to_use    = SEQUENCE;
            rhythm_to_use = rhythm;
        end

        notes = cell(1, seq_len);
        for i = 1:seq_len
            degree   = seq_to_use(i) + voice_offset;
            notes{i} = sprintf('%d.%d-', degree, rhythm_to_use(i));
        end
        out{end+1} = strjoin(notes, ', ');
    end

    out{end+1} = '';
end

% ---- Write file -------------------------------------------------------
addpath('sounds/');

fid = fopen(OUTPUT_SCORE, 'w');
if fid == -1
    error('Could not open output file: %s', OUTPUT_SCORE);
end
for i = 1:length(out)
    fprintf(fid, '%s\n', out{i});
end
fclose(fid);
fprintf('Score written to %s\n', OUTPUT_SCORE);

% ---- Format, synthesise, play ----------------------------------------
microtonal.notation.format_score(OUTPUT_SCORE);
buf = microtonal.notation.notation_to_audio(OUTPUT_SCORE);
microtonal.audio.play('parallel_chord_contrary', buf);
