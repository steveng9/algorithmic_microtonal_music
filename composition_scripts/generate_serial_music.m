% generate_serial_music.m
%
% Generates a 12-tone serial piece and writes it to a score file.
%
% Each row cycle assigns each voice a fresh random permutation of the
% 12 chromatic tones. Rhythm is controlled by INDEPENDENT_RHYTHMS:
%
%   false — all voices share the same durations per note position,
%           producing block chords. Each note is its own measure.
%
%   true  — each voice gets its own random durations that sum to the
%           same total, producing interleaving melodic lines. All 12
%           notes of a row cycle live in one measure per voice.
%
% ---- Parameters (edit these) ----------------------------------------

N_VOICES            = 2;
N_ROW_CYCLES        = 6;     % how many 12-note row cycles to generate
BPM                 = 80;
KEY                 = 'C major';
SOUND_FUNC          = 'crystal_bowl_with_pop';  % one function for all voices
INDEPENDENT_RHYTHMS = true;

% Octave shifts, one per voice (high -> low). Auto-generated if left empty.
OCTAVE_SHIFTS  = [];

OUTPUT_SCORE   = 'scores/serial_generated.txt';

% ---------------------------------------------------------------------

rng('shuffle');

if isempty(OCTAVE_SHIFTS)
    top = floor((N_VOICES - 1) / 2);
    OCTAVE_SHIFTS = top : -1 : top - (N_VOICES - 1);
end

if length(OCTAVE_SHIFTS) ~= N_VOICES
    error('OCTAVE_SHIFTS must have N_VOICES (%d) entries.', N_VOICES);
end

% 12 chromatic tones as major-scale degree tokens
chromatic_tokens = {'1','2f','2','3f','3','4','5f','5','6f','6','7f','7'};

% Duration pool in eighths (bias toward shorter values)
dur_pool = [1, 1, 2, 2, 2, 3, 4];

% ---- Build score lines -----------------------------------------------
out = {};

out{end+1} = 'Serial Piece';
out{end+1} = sprintf('(%d)', year(datetime('today')));
out{end+1} = 'generated by generate_serial_music.m';
out{end+1} = '';

for v = 1:N_VOICES
    out{end+1} = sprintf('voice: v%d, @%s, %d', v, SOUND_FUNC, OCTAVE_SHIFTS(v));
end

out{end+1} = '';
out{end+1} = sprintf('qtr_note = %d', BPM);
out{end+1} = KEY;
out{end+1} = '';

for rep = 1:N_ROW_CYCLES
    % Independent random row permutation per voice
    voice_rows = cell(N_VOICES, 1);
    for v = 1:N_VOICES
        voice_rows{v} = chromatic_tokens(randperm(12));
    end

    if INDEPENDENT_RHYTHMS
        % Each voice fills one measure with its own rhythm, all summing to
        % the same target duration so the measure lengths agree.
        target = sum(dur_pool(randi(length(dur_pool), 1, 12)));

        for v = 1:N_VOICES
            durs = random_durations_summing_to(12, target, dur_pool);
            notes = cell(1, 12);
            for n = 1:12
                notes{n} = sprintf('%s.%d', voice_rows{v}{n}, durs(n));
            end
            out{end+1} = strjoin(notes, ', ');
        end

    else
        % All voices share one duration per note position; each note is its
        % own measure so alignment is trivially satisfied.
        durations = dur_pool(randi(length(dur_pool), 1, 12));

        for v = 1:N_VOICES
            measures = cell(1, 12);
            for n = 1:12
                measures{n} = sprintf('%s.%d', voice_rows{v}{n}, durations(n));
            end
            out{end+1} = strjoin(measures, ' | ');
        end
    end

    out{end+1} = '';
end

% ---- Write file -------------------------------------------------------
addpath('sounds/');

fid = fopen(OUTPUT_SCORE, 'w');
if fid == -1
    error('Could not open output file: %s', OUTPUT_SCORE);
end
for i = 1:length(out)
    fprintf(fid, '%s\n', out{i});
end
fclose(fid);
fprintf('Score written to %s\n', OUTPUT_SCORE);

% ---- Format, synthesise, play ----------------------------------------
microtonal.notation.format_score(OUTPUT_SCORE);
buf = microtonal.notation.notation_to_audio(OUTPUT_SCORE);
microtonal.audio.play('serial_generated', buf);


% ---- Helper -----------------------------------------------------------
function durs = random_durations_summing_to(n, target, dur_pool)
    % Generate n positive random durations from dur_pool summing to target.
    durs = zeros(1, n);
    remaining = target;
    for i = 1:n-1
        % Cap so there is at least 1 eighth left for each note still to come
        max_allowed = min(max(dur_pool), remaining - (n - i));
        candidates  = dur_pool(dur_pool <= max_allowed);
        if isempty(candidates)
            candidates = 1;
        end
        durs(i)   = candidates(randi(length(candidates)));
        remaining = remaining - durs(i);
    end
    durs(n) = remaining;  % last note gets whatever is left
end
