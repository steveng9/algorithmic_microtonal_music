% parallel_chord_sequence.m
%
% Generates a 5-voice parallel-motion piece in Ab major.
%
% All voices start from a stacked block chord (CHORD_STACK) and move
% in parallel according to a fixed melodic sequence (SEQUENCE). Each
% repetition of the sequence shifts the whole texture up or down by
% a random step (0, ±1, ±2, or ±3) as a cumulative random walk.
%
% The rhythm is the same for every note position across all voices,
% so the block-chord texture is maintained throughout.
%
% ---- Parameters (edit these) ----------------------------------------

SEQUENCE      = [1, 2, 3, 4, 3, 2, 3, 1];  % melodic pattern (scale degrees)
CHORD_STACK   = [5, 1, 2, 4, 6];           % starting degree for each of 5 voices
RHYTHM        = [5, 4, 4, 4, 4, 5, 5, 6];  % duration in eighths per note position
N_REPETITIONS = 12;
BPM           = 250;
KEY           = 'Ab major';
SCALE         = [];  % custom TET scale, 1-indexed (e.g. [1,3,5,6,8,10,12]); [] = use mode name from KEY
SOUND_FUNC    = 'crystal_bowl_with_pop';
OCTAVE_SHIFTS = [1, 0, 0, -1, -2];          % one per voice, high to low

OUTPUT_SCORE  = 'scores/parallel_chord_sequence.txt';

% ---------------------------------------------------------------------

if length(SEQUENCE) ~= length(RHYTHM)
    error('SEQUENCE and RHYTHM must have the same length.');
end

n_voices = length(CHORD_STACK);
seq_len  = length(SEQUENCE);

if length(OCTAVE_SHIFTS) ~= n_voices
    error('OCTAVE_SHIFTS must have %d entries (one per voice).', n_voices);
end

rng('shuffle');

% Each voice's fixed offset from the sequence.
% voice v plays SEQUENCE(i) + offset(v) at step i.
% offset(v) = CHORD_STACK(v) - SEQUENCE(1)
base_offsets = CHORD_STACK - SEQUENCE(1);

% ---- Build score lines -----------------------------------------------
out = {};

out{end+1} = 'Parallel Chord Sequence';
out{end+1} = sprintf('(%d)', year(datetime('today')));
out{end+1} = 'generated by parallel_chord_sequence.m';
out{end+1} = '';

for v = 1:n_voices
    out{end+1} = sprintf('voice: v%d, @%s, %d', v, SOUND_FUNC, OCTAVE_SHIFTS(v));
end

out{end+1} = '';
out{end+1} = sprintf('qtr_note = %d', BPM);
if isempty(SCALE)
    out{end+1} = KEY;
else
    key_parts = strsplit(KEY);
    scale_str = strjoin(arrayfun(@num2str, SCALE, 'UniformOutput', false), ',');
    out{end+1} = sprintf('%s [%s]', key_parts{1}, scale_str);
end
out{end+1} = '';

% Possible per-repetition modulation steps; 0 appears twice for more stability
delta_options    = [-3, -2, -1, 0, 0, 1, 2, 3];
cumulative_delta = 0;

for rep = 1:N_REPETITIONS
    if rep > 1
        step             = delta_options(randi(length(delta_options)));
        cumulative_delta = cumulative_delta + step;
        % Soft clamp so the texture stays within a reasonable register
        cumulative_delta = max(-8, min(8, cumulative_delta));
    end

    for v = 1:n_voices
        voice_offset = base_offsets(v) + cumulative_delta;
        notes = cell(1, seq_len);
        for i = 1:seq_len
            degree  = SEQUENCE(i) + voice_offset;
            notes{i} = sprintf('%d.%d-', degree, RHYTHM(i));
        end
        out{end+1} = strjoin(notes, ', ');
    end

    out{end+1} = '';
end

% ---- Write file -------------------------------------------------------
addpath('sounds/');

fid = fopen(OUTPUT_SCORE, 'w');
if fid == -1
    error('Could not open output file: %s', OUTPUT_SCORE);
end
for i = 1:length(out)
    fprintf(fid, '%s\n', out{i});
end
fclose(fid);
fprintf('Score written to %s\n', OUTPUT_SCORE);

% ---- Format, synthesise, play ----------------------------------------
microtonal.notation.format_score(OUTPUT_SCORE);
buf = microtonal.notation.notation_to_audio(OUTPUT_SCORE);
microtonal.audio.play('parallel_chord_sequence', buf);
